### HTTP의 개념
+ 모든 웹 브라우저(클라이언트 프로그램)와 웹 서버(서버 프로그램)는 웹 상에서 일종의 규약을 지키면서 서로 요청과 응답을 주고 받는데 이 규약을 HTTP라고 한다.
+ 즉, HTTP는 HyperText Transfer Protocol(번역: 초 본문 전송 규약)의 약자로 웹 상에서 웹 브라우저와 웹 서버간 리소스(HTML 문서, 이미지, 동영상 등)를 주고받을 수 있는 일종의 규약이다.
+ HTTP를 통해 데이터를 주고 받을 때는 HTTP 요청(또는 응답) 메시지를 생성하여 이를 주고 받게 된다.
  + HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON(API), XML(API) 등 거의 모든 형태의 데이터를 전송할 수 있으며 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.
+ HTTPS(HyperText Transfer Protocol over Secure Socket Layer)는 보안이 강화된 웹 통신 프로토콜로 통신의 인증과 암호화를 위해 Netscape Communications가 개발했으며, 전자 상거래에서 널리 쓰인다.

<br/>

### HTTP의 역사
+ HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
+ HTTP/1.0 1996년: 메서드, 헤더 추가
+ HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전
  + RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
+ HTTP/2 2015년: 성능 개선
+ HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

<br/>

### (TCP or UDP) 기반 프로토콜
+ TCP: HTTP/1.1, HTTP/2
+ UDP: HTTP/3
+ 현재 HTTP/1.1 주로 사용
  + HTTP/2, HTTP/3 도 점점 증가

<br/>

### HTTP 특징
> 
> #### 클라이언트-서버 구조
> > + HTTP는 클라이언트-서버 모델을 따른다.
> > + 서버가 클라이언트의 요청을 대기(Listening) -> 클라이언트가 서버에 데이터 요청 및 서버의 응답 대기 -> 서버가 클라이언트에 데이터 응답
> > + 웹 애플리케이션에서는 클라이언트와 서버를 독립적으로 운영하는 것이 중요하다.
> >   + 클라이언트는 사용자 UX, UI 등에 집중할 수 있고, 서버는 트래픽 대응, 비즈니스 로직 등에 집중할 수 있기 때문이다.
> >   + 이때 클라이언트에서는 JSP를 사용하지 않고 HTML을 이용하고 API를 호출하여 서버로부터 데이터를 가져와 웹 페이지를 구성한다.
> 
> #### 무상태(스테이스리스, Stateless) 프로토콜
> > + 개념: 웹 서버가 웹 브라우저의 요청에 대한 응답을 하고 나면 해당 클라이언트와의 연결을 지속하지 않으며 클라이언트가 이전에 무엇을 했는지에 대한 정보를 기억 못한다.
> > + 장점: 서버 확장성이 높음(스케일 아웃) -> 무한한 서버 증설 가능
> >   + 웹 서버가 클라이언트의 정보를 저장하지 않으므로 특정 클라이언트를 전담하는 웹 서버가 따로 존재하지 않기 때문에 클라이언트의 요청이 급격히 늘어나도 서버 입장에서는 서버 대수를 늘리면 그만이다.
> >   ```
> >   ※ 상태 유지(Stateful) 프로토콜
> >   상태 유지(Stateful) 프로토콜은 **특정 클라이언트를 전담하는 서버**가 따로 있으므로 임의로 다른 서버로 바꾸면 안되며,
> >   전담하는 서버가 장애가 나면 해당 클라이언트는 처음부터 요청을 다시 시작해야한다.
> >   또한, 클라이언트의 요청이 급격히 늘어나서 서버 대수를 늘릴 시 **해당 클라이언트의 상태 정보를 다른 서버에 전달시켜줘야** 한다. 
> >   ```
> > + 단점: 클라이언트가 추가 데이터를 전송해야 함
> >   + 웹 브라우저(클라이언트) 입장에서는 서버에 이전에 보냈던 데이터를 또 전송해야한다.
> > + ##### Stateless 실무 한계
> >   + 모든 것을 무상태로 설계할 수도 있고 없는 경우도 있다.
> >   + 예를 들어, 로그인이 필요없는 단순한 정보 제공 서비스라면 모든 서버를 무상태로 설계해도 되지만,
> >   + 로그인 등 상태 유지가 필요한 서비스라면 상태 유지(웹 브라우저 쿠키 or 서버 세션)가 필요하다. **단, 상태 유지는 최소한만 사용하는 것이 중요하다.**
> 
> #### 비연결성(connectionless)
> > + 개념 : 클라이언트가 웹 서버에 요청하기 전 서로의 연결 상태를 확인하지만(TCP의 특성), 웹 서버가 클라이언트에 응답하고나면 서로의 연결 상태(TCP/IP 연결)를 종료시킨다.
> >   + 즉, HTTP는 기본적으로 연결을 유지하지 않는 모델로 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
> > + 장점 : 불특정 다수를 대상으로 하는 서비스에 적합하며 클라이언트와 서버가 계속 연결된 형태가 아니기 때문에 서버 자원을 매우 효율적으로 사용할 수 있어 클라이언트와 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.
> >   + 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
> >   + 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
> > + ##### 비연결성 한계와 극복
> >   + 한계 : 클라이언트 요청에 대해 매번 TCP/IP 연결을 새로 맺어야 하는데, 이는 3 way handshake 시간을 추가시킨다.
> >     + 더욱이 HTML 뿐만 아니라 자바스크립트, css, 이미지 등 리소스가 많을수록 이 시간은 길어진다.
> >   + 극복 : 이는 HTTP 지속 연결(Persistent Connections)로 문제를 해결할 수 있다. 리소스 하나하나에 대해서 TCP/IP 연결을 종료시키는 것이 아니라 일정 기간(일반적으로 60초) TCP/IP 연결을 유지시켜 그 시간이 종료될 때 TCP/IP 연결을 종료시키는 것이다.
> >     + 이는 HTTP/2, HTTP/3에서 더 많이 최적화가 되있다.

<br/>

### 백엔드 개발자들은 서버를 '스테이리스'하게 설계해야 한다.
+ 백엔드 개발자들은 서버를 설계할 때 어떻게 하면 무상태(스테이스리스)성을 많이 유지하게 할 수 있을지 고민해야 한다. 그렇게 하면 특정 시간에 딱 맞추어 발생하는 대용량 트래픽에 대응할 수 있는 여건들이 생긴다.
+ 예시 1) 사용자의 트래픽 분산시키기
  + 저녁 6:00 선착순으로 1000명 치킨 할인 이벤트를 한다고 가정해보자.
  + 이때 '이벤트 응모하기' 버튼을 사용자에게 첫 화면에 바로 노출시키는 것보다 처음에 로그인이 필요없는 즉, 상태 유지가 필요없는 정적인 웹 페이지가 먼저 노출되도록한다.
  + 사용자가 이벤트 응모하기 버튼을 클릭하기 전에 해당 페이지에서 어떤 유의사항들을 읽게 한다든가, 어떤 게임을 하게 한다든가, 설문을 참여하게 한다든가 하면
  + 이때 사용자별로 해당 작업들 처리하는데 시간이 다르게 소요되므로 응모하기(트랜잭션) 트래픽이 분산될 것이다.
+ 예시 2) 대기번호 부여하기
  + 별도 DB 서버를 두어 대기번호를 관리하도록 한다. 이를 통해 동시에 트래픽이 몰리는 것을 방지하고 순차적으로 요청들을 처리한다.
+ 하나의 DB 서버에 트랜잭션이 몰리는 경우 병목현상 해결방안
  + 데이터베이스 샤딩
  + 비동기 큐를 활용한 데이터 저장

<br/>

### 참고자료
+ 부스트코스 웹 프로그래밍(풀스택)
+ 인프런 모든 개발자를 위한 HTTP 웹 기본 지식
